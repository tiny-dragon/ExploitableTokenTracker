// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import excuteQuery from "@/lib/database";
import axios from "axios";
import type { NextApiRequest, NextApiResponse } from "next";

const BSCSCAN_API_KEY = process.env.BSCSCAN_API_KEY;

console.log(BSCSCAN_API_KEY);

export type Chain = {
  id: number;
  name: string;
};

export type Token = {
  id: number;
  tokenId: string;
  name: string;
  symbol: string;
  chainId: number;
  address: string;
  has1: number;
};

export enum TokenStatus {
  NotVerified = 0,
  Good = 1,
  Can = 2,
  Exploitable = 3,
}

const fetchTokenAddresses = async () => {
  try {
    const chainList: Chain[] = [];
    let queryRes = await excuteQuery({
      query: "SELECT * FROM chains;",
    });

    if (Array.isArray(queryRes)) {
      queryRes.forEach((chain) =>
        chainList.push({ id: chain.id, name: chain.name })
      );
    }

    const tokenList: Token[] = [];
    queryRes = await excuteQuery({ query: "SELECT * FROM tokens;" });
    if (Array.isArray(queryRes)) {
      queryRes.forEach((token) =>
        tokenList.push({ ...token, chainId: parseInt(token.chainId) })
      );
    }

    console.log(tokenList);
    // Get all token contract addresses
    const res = await axios.get(
      "https://api.coingecko.com/api/v3/coins/list?include_platform=true"
    );

    for (const token of res.data) {
      if (!token.platforms || Object.keys(token.platforms).length === 0)
        continue;

      for (const platform of Object.keys(token.platforms)) {
        let index = (chainList as Chain[]).findIndex(
          (chain) => chain.name === platform
        );

        let chainId = index >= 0 ? chainList[index].id : -1;

        if (chainId === -1) {
          const result = await excuteQuery({
            query: "INSERT INTO chains (name) VALUES (?)",
            values: [platform],
          });

          chainId = (result as { insertId: number }).insertId;
          chainList.push({ id: chainId, name: platform });
        }

        const tokenInfo = {
          tokenId: token.id,
          symbol: token.symbol,
          name: token.name,
          address: token.platforms[platform],
          chainId,
        };

        index = tokenList.findIndex(
          (t) =>
            t.address === tokenInfo.address && t.chainId === tokenInfo.chainId
        );

        if (index === -1) {
          await excuteQuery({
            query:
              "INSERT INTO tokens (tokenId, symbol, name, address, chainId, has1) VALUES (?, ?, ?, ?, ?, ?)",
            values: [
              tokenInfo.tokenId,
              tokenInfo.symbol,
              tokenInfo.name,
              tokenInfo.address,
              tokenInfo.chainId,
              TokenStatus.NotVerified,
            ],
          });
        }
      }
    }
  } catch (e) {
    console.log(e);
  }
};

const getContractAbi = async (address: string) => {
  const url = `https://api.bscscan.com/api?module=contract&action=getabi&address=${address}&apikey=${BSCSCAN_API_KEY}`;
  const response = await axios.get(url);
  const data = response.data;

  console.log(address);

  if (data.status === "1") {
    return JSON.parse(data.result);
  } else {
    console.log(address);
    throw new Error(`Failed to fetch ABI: ${data.message}`);
  }
};

const hasPublicBurn = (abi: any[]) => {
  const burnFunctions = [
    "function burn(address,uint256)",
    "function burnFrom(address,uint256)",
  ];

  return abi.some((item) => {
    if (item.type !== "function") return false;

    const signature = `${item.type} ${item.name}(${item.inputs
      .map((input: { type: any }) => input.type)
      .join(",")})`;
    return burnFunctions.includes(signature);
  });
};

const checkTokenStatus = async () => {
  let queryRes = await excuteQuery({
    query: "SELECT * FROM chains WHERE name='binance-smart-chain'",
  });
  const binanceChainId = Array.isArray(queryRes) ? queryRes[0].id : -1;

  queryRes = await excuteQuery({
    query:
      "SELECT * FROM tokens WHERE chainId=? AND (ISNULL(has1) OR has1=?) LIMIT 5",
    values: [binanceChainId, TokenStatus.NotVerified],
  });

  if (Array.isArray(queryRes)) {
    queryRes.forEach(async (token) => {
      try {
        const abi = await getContractAbi(token.address);
        const hasBurn = hasPublicBurn(abi);

        await excuteQuery({
          query: "UPDATE tokens SET has1=? WHERE chainId=? AND address=?",
          values: [
            hasBurn ? TokenStatus.Can : TokenStatus.Good,
            binanceChainId,
            token.address,
          ],
        });
      } catch (e) {
        console.log(e);
      }
    });
  }
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    await fetchTokenAddresses();
    await checkTokenStatus();
  } catch (e) {
    console.log(e);
  }
  res.status(200).json({ status: "success" });
}
